package com.sxt.study.interview.gitchat;

import com.sxt.study.interview.InterviewApplicationTests;
import org.junit.Test;

/**
 * @author songj
 * @date 2019/9/2 8:57
 */
public class JavaBaseSixTest extends InterviewApplicationTests {

    @Test
    public void test171(){
        /**
         * 171. MySQL 索引是怎么实现的？
         *
         * 索引是满足某种特定查找算法的数据结构，
         * 这些数据结构会以某种方式指向数据，
         * 从而实现高效查找数据。
         *
         * 主流的数据库引擎的索引都是 B+ 树实现的，可以达到二分法的性能
         * 找到数据区域之后就找到了完整的数据结构
         * 
         */
    
    }
    
    @Test
    public void test172(){
        /**
         * 172. 怎么验证 MySQL 的索引是否满足需求？
         *
         * explain 查看SQL
         * 
         */
    
    }
    
    @Test
    public void test173(){
        /**
         * 173. 说一下数据库的事务隔离？
         *
         * 读未提交：事务未提交前，可被其它事务读取，有幻读、脏读、不可重复读
         * 读已提交：一个事务提交后才可被其它事务读取，有幻读、不可重复读
         * 可重复读：（MySQL默认基本）禁止读取到别的事务未提交的数据，保证多次读取同一个数据时，其值和事务开始的时候内容一致，有幻读
         * 序列化：代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读
         *
         * 脏读：表示一个事务读取另一个事务未提交数据
         * 不可重复读：一个事务内，多次读取同一个数据，值不同
         * 幻读：指同一个事务内多次查询返回的结果集不一样
         * 
         */
    
    }

    @Test
    public void test174(){
        /**
         * 174. 说一下 MySQL 常用的引擎？
         *
         * InnoDB引擎：支持事务，提供了行级锁和外键的约束，设计目标是使MySQL成为处理大数据量的数据库系统
         * InnoDB 写操作是不会锁定全表的，在并发度较高的场景下使用会提升效率的
         *
         * MyIASM引擎：不支持事务不提供行级锁和外键的约束，写操作需要锁表，会降低效率。但是会记录表的行数
         * 应用场景：读操作远多于写操作，并且不需要事务的支持
         * 
         */
    
    }

    @Test
    public void test175(){
        /**
         * 175. 说一下 MySQL 的行锁和表锁？
         *
         * InnoDB引擎 支持行锁和表锁，默认行锁
         * MyIASM引擎 支持表锁
         *
         * 表锁，开销小，加速快，不会出现死锁。锁定粒度大，发生锁冲突的概率大，并发量低
         * 行级锁，开销大，加锁慢，会出现死锁。锁定粒度小，发生锁冲突的概率小，并发度高
         *
         * 
         */
    
    }
    
    @Test
    public void test176(){
        /**
         * 176. 说一下乐观锁和悲观锁？
         *
         * 乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，
         * 但是在提交更新的时候会判断一下在此期间数据有没有被修改。
         *
         * 悲观锁：每次去拿数据的时候都认为别人会修改，所以会上锁，
         * 这样别人拿数据就会被阻止，直到锁被释放
         *
         * 乐观锁实现，表里加一个version字段，每次更新加1，
         * 修改时进行比较，自己的和数据库里的不一致则不修改
         * 
         */
    
    }
    
    @Test
    public void test177(){
        /**
         * 177. MySQL 问题排查都有哪些手段？
         *
         * explain sql语句
         *
         * 开启慢查询日志，查看慢SQL
         *
         * 使用 show processlist 命令查看当前所有连接信息
         * 
         */
    
    }

    @Test
    public void test178(){
        /**
         * 178. 如何做 MySQL 的性能优化？
         *
         * 为搜索字段加索引
         * 避免使用 select * ，列出需要查询的字段
         * 选择正确的存储引擎
         * 垂直分割表
         * 
         */
    
    }
    
    @Test
    public void test179(){
        /**
         * 179. Redis 是什么？都有哪些使用场景？
         *
         * 高速缓存数据库 NoSql
         * 场景：
         * 记录用户会话信息
         * 缓存文章（用户）详情信息
         * 缓存近期热帖
         * 记录帖子点赞数、点击数
         * 
         */
    
    }
    
    @Test
    public void test180(){
        /**
         * 180. Redis 有哪些功能？
         *
         * 数据缓存
         * 分布式锁
         *
         * 支持数据持久化
         * 支持事务
         * 支持消息队列
         *
         * session共享
         * 分布式锁
         * 数据缓存
         * 
         */
    
    }
    
    @Test
    public void test181(){
        /**
         * 181. Redis 和 memcache 有什么区别？
         *
         * 1.Redis key-value 数据类型：string、hash、list、set、zset(带权重)
         * memcache 对数据类型支持相对简单
         *
         * 2.Redis 支持持久化，memcache 不支持持久化
         *
         * 3.value值大小不同，Redis值大
         *
         * 4.使用底层模型不同，与客户端之间通信协议不一样
         * 
         */
    
    }
    
    @Test
    public void test182(){
        /**
         * 182. Redis 为什么是单线程的？
         *
         * 因为CPU不是Redis的性能瓶颈，是机器内存和网络带宽，且单线程容易实现
         * 
         */
    
    }
    
    @Test
    public void test183(){
        /**
         * 183. 什么是缓存穿透？怎么解决？
         *
         * 缓存穿透：查询一个一定不存在的数据，由于缓存中未命中时需要查询数据库，
         * 查不到数据则不写入缓存
         * 这导致这个不存在的数据每次请求都要查数据库，造成缓存穿透。
         *
         * 如果一个查询返回的结果为空，把这个空结果进行缓存，但它的过期时间会很短，最长不超过5分钟
         * 
         */
    
    }
    
    @Test
    public void test184(){
        /**
         * 184. Redis 支持的数据类型有哪些？
         *
         * string/list/hash/set/zset
         * 
         */
    
    }

    @Test
    public void test185(){
        /**
         * 185. Redis 支持的 Java 客户端都有哪些？
         *
         * jedis/lettuce/Redisson
         * 
         */
    
    }

    @Test
    public void test186(){
        /**
         * 186. jedis 和 Redisson 有哪些区别？
         *
         * jedis:提供了比较全面的Redis命令支持
         *
         * Redisson:实现了分布式和可扩展的java数据结构
         * 
         */
    
    }
    
    @Test
    public void test187(){
        /**
         * 187. 怎么保证缓存和数据库数据的一致性？
         *
         * 合理设置 缓存的过期时间
         * 新增、更改、删除数据库操作同步更新Redis缓存，可以使用事务机制来保证数据的一致性
         * 
         */
    
    }
    
    @Test
    public void test188(){
        /**
         * 188. Redis 持久化有几种方式？
         *
         * RDB:指定时间间隔对数据进行快照存储
         * AOF:每一个收到的写命令都追加到文件中
         * 
         */
    
    }
    
    @Test
    public void test189(){
        /**
         * 189. Redis 怎么实现分布式锁？
         *
         * 分布式锁 是在系统里有一个坑，其它程序要占坑的时候，占用成功了就继续执行，失败了就能放弃或稍后重试
         *
         * 用 setnx 指令，只允许被一个程序获取，使用完释放锁，设置锁超时时间
         * 
         */
    
    }

    @Test
    public void test190(){
        /**
         * 190. Redis 分布式锁有什么缺陷？
         *
         * 不能解决超时的问题，分布式锁有一个超时时间，程序的执行时间超出了锁的超时时间就会出现问题
         *
         * 增大锁的超时时间
         * 
         */
    
    }

    @Test
    public void test191(){
        /**
         * 191. Redis 如何做内存优化？
         *
         * 不要把每个字段单独存储，尽量使用Redis的散列表，整体存储
         * 
         */
    
    }

    @Test
    public void test192(){
        /**
         * 192. Redis 淘汰策略有哪些？
         *
         * 从已设置过期时间的数据集中，挑选最近最少使用的数据淘汰
         * 挑选将要过期的数据淘汰
         * 任意选择数据淘汰
         *
         * 从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰
         * 从数据集（server. db[i]. dict）中任意选择数据淘汰
         *
         * 禁止驱除数据
         *
         * 
         */
    
    }
    
    @Test
    public void test193(){
        /**
         * 193. Redis 常见的性能问题有哪些？该如何解决？
         *
         * Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内
         *
         * 主服务器写内存快照，会阻塞主线程的工作，当快照较大时对性能影响较大，会间断性暂停服务，
         * 所以主服务器不要写内存快照
         * 
         */
    
    }

    @Test
    public void test194(){
        /**
         * 194. 说一下 JVM 的主要组成部分？及其作用？
         *
         * 类加载器：把java代码转换成字节码
         * 运行时数据区：把字节码加载到内存中，字节码文件只是JVM的一套指令集规范，不能直接交给底层操作系统执行
         * 执行引擎：将字节码翻译成底层系统指令，再交由CPU去执行，这个过程需要调用本地库接口
         * 本地库接口：由执行引擎调用
         * 
         */
    
    }
    
    @Test
    public void test195(){
        /**
         * 195. 说一下 JVM 运行时数据区？
         *
         * 程序计数器：当前线程所执行的字节码的行号指示器，字节码解析器通过改变计数器的值来选取下一条需要执行的字节码指令
         * Java虚拟机栈：用于存储 局部变量、操作数栈、动态链接、方法出口等信息
         * 本地方法栈：与虚拟机栈作用一致，为虚拟机调用native方法服务
         * Java 堆：Java虚拟机中内存最大的一块，是被所有线程共享的，几乎所有对象实例都在这里分配内存
         * 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
         * 
         */
    
    }
    
    @Test
    public void test196(){
        /**
         * 196. 说一下堆栈的区别？
         *
         * 堆用来存放对象，栈存的是引用，局部变量，用来执行程序
         * 堆是线程共享的，栈是线程私有的
         * 堆大小远大于栈
         * 
         */
    
    }

    @Test
    public void test197(){
        /**
         * 197. 队列和栈是什么？有什么区别？
         *
         * 用来预存储数据
         * 队列允许 先进先出检索元素 Deque 接口允许从两端检索元素
         * 栈 后进先出进行检索元素
         * 
         */
    
    }
    
    @Test
    public void test198(){
        /**
         * 198. 什么是双亲委派模型？
         *
         * 双亲委派模型：如果一个类加载器收到了加载类的请求，
         * 它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，
         * 每一层的类加载器都是如此，这样所有的加载请求都会到顶层的启动类加载器中，
         * 只有当父类加载器无法完成加载时，子加载器才会尝试去加载类
         *
         * 避免重复加载类，安全因素
         *
         * 类加载器分类
         * 应用程序类加载器 Application ClassLoader
         * 扩展类加载器  Extension ClassLoader
         * 启动类加载器  Bootstrap ClassLoader
         * 
         */
    
    }
    
    @Test
    public void test199(){
        /**
         * 199. 说一下类装载的执行过程？
         *
         * 加载：根据查找路径找到相应的class文件然后载入
         * 检查：检查class文件的正确性
         * 准备：给类中的静态变量分配内存空间
         * 解析：虚拟机将常量池中的符号引用替换为直接引用的过程
         * 初始化：对静态变量和静态代码块执行初始化
         * 
         */
    
    }

    @Test
    public void test200(){
        /**
         * 200. 怎么判断对象是否可以被回收？
         *
         * 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，计数器为0 时回收
         *
         * 可达性分析：当一个对象没有引用链相连时，此对象是可以被回收的
         *
         */

    }

    @Test
    public void test201(){
        /**
         * 201. Java 中都有哪些引用类型？
         *
         * 强引用：发送GC时不会被回收
         * 软引用：有用但不是必须的对象，在发生内存溢出之前回收
         * 弱引用：有用但不是必须的对象，在下一次GC时被回收
         * 虚引用：无法通过虚引用获得对象，在GC时返回一个通知
         * 
         */
    
    }

    @Test
    public void test202(){
        /**
         * 202. 说一下 JVM 有哪些垃圾回收算法？
         *
         * 标记清除算法：标记无用对象，然后进行清除回收
         * 标记整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存
         * 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉
         * 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代采用复制算法，老年代采用标记整理算法
         * 
         */
    
    }
    
    @Test
    public void test203(){
        /**
         * 203. 说一下 JVM 有哪些垃圾回收器？
         *
         * Serial：最早的单线程串行垃圾回收器
         *
         * ParNew：多线程
         *
         * CMS：一种以获取最短停顿时间为目标的垃圾回收器
         *
         * G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项
         *
         */
    
    }

    @Test
    public void test204(){
        /**
         * 204. 详细介绍一下 CMS 垃圾回收器？
         *
         * Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。
         * 对于要求服务器响应速度的应用，这种垃圾回收器最适合
         * 在启动JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器
         *
         * CMS 使用标记清除算法实现，在GC 时会产生内存碎片
         * 
         */
    
    }

    @Test
    public void test205(){
        /**
         * 205. 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？
         *
         * 新生代垃圾回收器：Serial、ParNew、Parallel Scavenge
         * 老年代垃圾回收器：Serial Old、ParNew Old、CMS
         * 整堆回收器：G1
         *
         * 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；
         * 老年代回收器一般采用的是标记-整理的算法进行垃圾回收
         * 
         */
    
    }
    
    @Test
    public void test206(){
        /**
         * 206. 简述分代垃圾回收器是怎么工作的？
         *
         * 分代垃圾回收器分区：新生代和老年代 默认新生代占总空间1/3、老年代占总空间2/3
         *
         * 新生代使用复制算法，新生代有3个分区：Eden、To Survivor、From Survivor
         * 默认占比 8:1:1 ，执行流程如下：
         * 把Eden、From Survivor存活的对象放入 To Survivor中
         * 清除 Eden 、From Survivor 分区
         * From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor
         *
         * 每次在From Survivor与To Survivor 移动时，存活的对象年龄+1，当年龄达到15时，就升级为老年代。大对象直接进入老年代
         *
         *
         * 老年代当空间占用到达某个值之后就会触发全局垃圾收回，使用标记整理算法，
         *
         * 以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
         * 
         */
    
    }
    
    @Test
    public void test207(){
        /**
         * 207. 说一下 JVM 调优的工具？
         *
         * jconsole：用于对JVM中的内存、线程和类进行监控
         * jvisualvm：jdk自带的全能分析工具，可分析内存快照、线程快照、程序死锁、监控内存的变化、gc变化等
         * 
         */
    
    }
    
    @Test
    public void test208(){
        /**
         * 208. 常用的 JVM 调优的参数都有哪些？
         *
         * -Xms2g：初始化推大小为 2g；
         * -Xmx2g：堆最大内存为 2g；
         * -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4
         * -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
         * –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合
         * -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合
         * -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合
         * -XX:+PrintGC：开启打印 gc 信息
         * -XX:+PrintGCDetails：打印 gc 详细信息
         * 
         */
    
    }
}
